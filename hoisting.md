# 호이스팅
선언문을 끌어올리는 동작을 호이스팅이라고 한다. 
```
a =2 ;
var a;
console.log(a); //2 
```
```
foo();
function foo(){
    console.log(a) // undefined
    var a = 2;
}
```
함수 foo의 선언문은 끌어 올려져서 foo를 첫째 줄에서 호출할 수 있다. 

# 함수가 우선.
함수와 변수 선언문은 모두 끌어올려진다. 그러나 미묘한 차이가 있는데, 먼저 함수가 끌어올려지고 다음으로 변수가 올려진다. 

# 정리하기
var a =2; 는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다. 엔진은 이를 var a와 a =2 라는 두개의 독립된 구문으로 보고, 첫째 구문은 컴파일러 단계에서 처리하고, 둘째 구문은 실행 단계에서 처리한다. 
스코프의 모든 선언문은 어디서 나타나는 실행 전에 먼저 처리된다는 점이다. 호이스팅이라고 불리는 이 과정은 선언문 각각이 속한 스코프의 꼭대기로 끌어올려 지는 작업이라고 생각할 수 있다. 그 과정에서 선언문 자체는 옮겨지지만, 함수 표현식의 대입문을 포함한 모든 대입문을 끌어 올려지지 않는다. 

# 실행 컨텍스트 
실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아 넣은 객체로, 자비스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있다. 

스택: 출입구가 하나뿐인 깊은 우물 같은 데이터 구조로 비어있는 스택에 순서대로 a,b,c,d를 저장한다면, 꺼낼때는 d,c,b,a의 순서로 꺼낼 수 밖에 없다. 

큐: 양방향? 종류에 따라 양쪽 모두 입력과 출력이 가능한 큐도 있으나, 한쪽은 입력만, 한쪽은 출력만을 담당하는 구조를 말한다. 큐에 순서대로 데이터 a,b,c,d를 저장했다면, 꺼낼 때도 역시 a,b,c,d의 순서로 꺼낸다. 

실행 컨텍스트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아 올렸다가, 가장 위에 쌓여 있는 컨텍스트와 관련있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장. 

'동일한 환경', 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으론 전역공간, eval()함수, 함수 등이 있습니다. 자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것. 
```
var a =1; 
function outer(){
  function inner(){
    console.log("1번째"+ a); //1 책에서는 undefined
  }
  inner();
  console.log("2번째"+a); //1
}
outer();
console.log("3번째" + a); //1
```

전역 컨텍스트가 콜 스택에 담기고, 최상단의 공간은 코드 내부에서 별도의 실행 명령 없이도 브라우저에서 자동으로 실행하므로, 

자바스크립트 파일이 열리면 전역 컨텍스트가 활성화 된다. 

콜 스택은 전역 컨텍스트 외에 다른 덩어리가 없으므로, 전역 컨텍스트와 관련된 코드들을 순차로 진행하다가, outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성 후 콜스택에 담는다. 콜 스택의 맨위에 outer 실행 컨텍스트가 놓인 상태가 되면서, 전역 컨텍스트와 관련된 코드의 실행을 일시중단 하고, outer 실행 컨텍스트와 관련된 코드, outer 함수 태부의 코드들을 순차로 실행한다. inner 함수가 실행되면, 콜 스택의 가장 위에 담긴 outer 컨텍스트와 관련된 코드의 실행 중단하고, inner함수 내부의 코드를 순서대로 진행한다. inner함수 내부에서 a 변수에 3을 할당하고, inner 함수는 실행이 종료되고, inner 실행 컨텍스트가 콜 스택에서 제거. outer 컨텍스트가 콜 스택에 위에 존재하므로, 중단되었던 줄 부터 이어서 실행. a값을 출력하고, outer 함수의 실행이 종료되고, outer가 실행 컨텍스트가 콜 스택에서 제거됨. 콜 스택에는 전역 컨텍스트만 남음. 

실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점. 기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치하고, 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장. 

VariableEnvironment. 

variable Environment에 담기는 내용은, 최초 실행 시의 스냅샷을 쥬지한다. 실행 컨텍스트를 생성할때 variable Environment에 정보를 먼저 담은 다음, 이를 그대로 복사하여 lexical Environment를 만들고, 이후에는 lexical Evironment를 주로 활용한다. 

Lexical Environment :어휘적 환경, 정적 환경. 예) 백과사전에서 바나나를 검색하면 가장 먼저 칼로리가 가장 높고 당질이 많은 알카리성 식품으로 칼륨, 카로틴, 비타민c를 함유하고 있다.현재 컨텍스트 내부에는 a,b,c같은 식별자들이 있고, 그 외부 정보는 D를 참조하도록 구성돼있다. 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것. 

environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장되어 있다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당한다. 컨텍스트 내부 전체를 처음부터 끝까지 훑어나가며 순서대로 수집한다. 변수 정보를 수집하는 과정을 모두 마쳤더라도, 아직 실행 컨텍스트가 관여할 코드가 실행되지 않은 상태. 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 된다. 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심있고, 어떤 값이 할당될 것인지는 관심없음. 변수를 호이스팅할때 변수명만 끌어올리고, 할당 과정은 원래 자리 그대로 남겨둔다. 매개변수의 경우에도 마찬가지.

'자바스크립트 엔진은 식별자들을 최상단으로 끌어올려 놓은 다음, 실제 코드를 실행한다.'라고 생각하자. 호이스팅이 여기서의 끌어올림이다. 

전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체, 즉 전역 객체를 활용한다. 전역객체에는 브라우저의 window, node.js의 global 객체 등이 있다. 이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류된다.

```

function a(x){
  console.log(x);
  var x;
  console.log(x);
  var x =2;
  console.log(x);
}
a(1);

function a(x){
  var x= 1; 
  console.log(x);
  var x;
  console.log(x);
  var x=2;
  console.log(3);
}
a();

//hoisting 과정
function a(){
  var x;
  var x;
  var x;
  
  x=1;
  console.log(x);
  console.log(x);
  x=2;
  console.log(x);
}

//그래서 값이 1,1,2가 나옴 1, undefined,2가 아니라. 
```
